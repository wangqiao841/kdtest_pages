# OA_WebUI插件方法说明
## 注意
只针对TDOA Web端做操作如“人员选择”、“日期选择”、“模块跳转”等等，该插件中的方法只在内部使用，目的则是为了方便对OA系统书写测试用例，正式发布的框架中不存在该插件。
> 注意：OA_WebUI插件中的所有方法均不支持在脚本中使用
## userLogin方法
> 用户登录

**描述**<br/>
针对OA系统web端的登录页面做操作

**参数**<br/>
@param **userName** `string类型`：用户名 <br/>
@param **userPassword** `string类型`：密码 <br/>
> userName 和 userPassword 两参数均可省略

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]userLogin |   |  {'userName':'admin','userPassword':'123'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]userLogin |  |  | {'userName':'admin','userPassword':'123'}

**注意事项**
* 方法中的 **userName** 和 **userPassword** 参数所接收的值类型均为 string类型。
* 支持两种参数传递方式分别为：`{'userName':'xxx','userPassword':'xxx'}` 、`['xxx','xxx']`。

## jumpFrame方法
> iframe焦点一次性多级跳转

**描述**<br/>
对页面中的iframe焦点进行一次性的多级跳转

**参数**<br/>
@param **Hierarchy** `list类型`：代表要跳转的frame的层级，以及对应层级的节点

**参数说明**
* Hierarchy参数书写规则  [n, [iframe节点,...]]: 
	+ n： 要进行跳转的层级个数，大于等于0
	+ [iframe节点,...]： 要进行跳转的iframe节点列表，个数要与“N进行跳转的层级个数”一致，单个节点可以是“标签id属性值”、“标签页面索引”、“标签src属性值”其中的任意一个
* Hierarchy参数合法书写示例：`[3, ['iframe1',0,'/portal/home/']]`  或者  `[2, ['iframe1','/portal/home/']] `

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]jumpFrame|   |  {'Hierarchy':[n,[xxx,xxx...]]}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]jumpFrame|  |  |  {'Hierarchy':[n,[xxx,xxx...]]}

**注意事项**
* 方法是对OA系统中“多层级iframe标签嵌套”的解决方案，用于一次性的多层级iframe焦点跳转。
* 方法支持两种传值方式分别为 “`[xx,xx...]列表顺序传参`”、“`{'参数名':'参数值'...}字典指定参数传参`”，你可以根据实际情况书写。
* 方法中的可以处理三种类型的“iframe节点”分别为 “标签id属性值”、“标签页面索引”、“标签src属性值”。
* 方法不做正确性判断，注意传入的层级节点的对应关系是否正确。

## errorHandle方法
> OA系统“强制”错误提示处理

**描述**<br/>
对OA系统中的 “alert弹框”、“系统信息提示框”、“右上角消息弹框”进行识别和处理，提示处理优先级为 alert弹框 > 系统信息提示框 > 右上角消息弹框

**参数**<br/>
@param **type** `布尔类型`：`True`代表点击alert弹框的【确定】按钮，`False`代表点击alert弹框的【取消】按钮，若省略则为`False`<br/>
@param **prompt_input** `string类型`：代表在alert - prompt类型弹框时要输入的文本内容<br/>
> type 和 prompt_input 两参数均可省略

**参数说明**
* 不传参：一个单按钮的alert弹框(不管按钮是【确认】还是【取消】)，或者一个系统提示信息(不管是否存在按钮)，或者右上角的一个消息弹框，你可以直接调用该插件方法而不需要传任何值；
* type传参：一个双按钮的alert提示框，传入`True`就代表以点击【确认】按钮来处理这个alert弹框。若不传值或者传入`False`就代表以点击【取消】按钮来处理这个alert弹框；
* prompt_input传参：一个alert - prompt类型弹框需要你输入一个值之后才可处理，prompt_input就代表你要输入的值，若是此时type为空则代表点击prompt弹框的【取消】按钮；
* type、prompt_input同时传参：一个alert - prompt类型弹框需要你输入一个值之后在点击【确认】按钮，此时prompt_input传入你要输入的值，type传入True；

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]errorHandle|   |  {'type':True,'prompt_input':'要输入的内容'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]errorHandle|  |  |  {'type':True,'prompt_input':'要输入的内容'}

**注意事项**
* 方法处理的优先级为 alert弹框 > 系统信息提示框 > 右上角消息弹框。
* 插件方法会自动识别当前页面中的“alert弹框”、“系统信息提示框”、“右上角消息提示框”，如果在同时出现则优先处理权重较高的。
* 插件方法支持两种传值方式分别为 “[xx,xx...]列表顺序传参”、“{'参数名':'参数值'...}字典指定参数传参”，你可以根据实际情况书写。
* 方法的处理取决于实际的页面场景，并不是你传入`type=True`就会点击alert的【确定】按钮，也不是你传入`prompt_input=“xxx”`就会在prompt弹框中输入值。故方法需要你结合实际的页面表现使用。

## WeakHint方法
> OA系统“文本弱提示”处理

**描述**<br/>
用于处理一些OA系统中的弱提示弹框；方法存在返回值，返回值为`string`类型，是当前页面中所有弱提示文本的字符串拼接
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/5de79545ca5a49c9847d4cf7af3ca175.png)
> 
**参数**<br/>
无参

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]WeakHint |   |

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]WeakHint |  |  |

**注意事项**
* 方法会自动识别当前页面中弹出的所有弱提示弹框，并获取它们的提示文本。
* 方法只获取它们的提示文本而并不会关闭它们。

## personnelChoice方法 
> OA系统“人员选择组件”操作

**描述**<br/>
根据传入的“待选人员信息”，对系统中的“人员选择组件”进行操作，完成人员选择
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/70914a8314dd43ffa5a554532665cf3c.png)

**参数**<br/>
@param **type** `string类型`：人员选择方式标识<br/>
@param **dataList** `list类型`：按“部门”、“角色”、“分组”方式选择时的人员信息<br/>
@param **name** `string类型`：人员检索选择时的人员姓名<br/>
@param **department** `string类型`：部门人员全选时的部门名称<br/>
> dataList、name 和 department 参数可省略

**参数说明**
* type参数解释：
	+ 人员选择方式标识，参数合法值： `'0'`部门、`'1'`角色、`'2'`分组、`'3'`在线、`'4'`检索
* dataList参数解释：
	+ 按照部门选择输入参数为：`dataList=[部门名称，人员姓名]` 用来存放按照部门进行添加时的人员和部门信息
	+ 按照角色选择输入参数为：`dataList=[人员角色名称，人员姓名]` 用来存放按照角色进行添加时的人员和角色信息
	+ 按照分组选择输入参数为：`dataList=[分组名称，人员姓名]` 用来存放按照分组进行添加时的人员和分组信息
	+ 按照部门选择时，单纯的一级目录结构参数格式为：`dataList = [部门名称，人员姓名]`。
	+ 大于一级的目录结构参数格式为：`dataList = [num(目录层级2,3,4..n)，[父级目录名称，子级目录名称...n]，人员姓名]`； 例如: ` dataList=[4,['市场营销部', '销售部', '北京销售部', '销售三组'],'温炳康']`。
	+ dataList参数在使用时，需要根据添加方式将type的值填充为'0'、'1'、'2'。
* name参数解释：
	+ 用来存放按照“检索方式”进行人员选择时的人员姓名。
	+ 使用“检索方式”进行人员选择，若出现两个同名人员的情况，则默认选择检索结果列表中的第一个条人员记录。
	+ name参数在使用时需要将type的值填充为'4'(检索方式添加)。
* department参数解释：
	+ 用于存放当需要将整个部门的人员全部添加时的目标部门名称。
	+ department参数在使用时需要将type的值填充为'0'(部门方式添加)。

**方法使用场景示例**：
* 通过“部门方式”选择“综合管理部 - 行政部 - 张敏”：`{'type': '0', 'dataList': [2,['综合管理部', '行政部'],'张敏']}`
* 通过“在线方式”选择在线列表中的第一条人员记录：`{'type': '3'}`
* 通过“检索方式”选择“王德”：`{'type': '4', 'name': '王德'}`
* 将综合管理部中的人员全部选中：`{'type': '0', 'department': '综合管理部'}`

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]personnelChoice|   | {'type':'选人方式'[, 'dataList':操作值][,'name':'检索人员姓名'][,'department':'部门名称']}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]personnelChoice|  |  |  {'type':'选人方式'[, 'dataList':操作值][,'name':'检索人员姓名'][,'department':'部门名称']}

**注意事项**
* 方法仅支持一种传值方式：“{'参数名':'参数值'...}字典指定参数传参”。
* 方法在通过“`在线 type=3`”方式进行人员选择时，`dataList 参数`、`name 参数`、`department 参数`均不需要传值，方法将自动选择“人员在线列表”中的第一条人员记录。

## setDate方法
> OA系统“日期选择组件”操作

**描述**<br/>
根据传入的“日期参数”信息，对系统中的“日期选择组件”进行操作，完成日期选择
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/3c733a36d31e497084ea61254d09e4bb.png)

**参数**<br/>
@param **expectDate** `string类型`：代表要进行选择的日期<br/>

**参数说明**
* 注意传入的日期，数据格式应为“YYYY-MM-DD”(2021-09-24 或者 2021-9-24)，其它的日期格式方法无法识别。

**方法使用场景示例**
* 你可以直接输入一个日期让其选择：`['2021-9-24']`  ||  `{'expectDate': '2021-9-24'}`
* 你可以与内置函数配置使用，让其选择当前系统日期+1：`['Increasing_date(System_date(%Y-%m-%d), 1)']`  ||  `{'expectDate': 'Increasing_date(System_date(%Y-%m-%d), 1)'}`
* 你可以让其输入一个在测试过程中通过getElementText关键字获取到的日期(通过‘time’键名保存)：`['get_PrestoreData(time)'] ` ||  `{'expectDate': 'get_PrestoreData(time)'}`

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]setDate|   |  {'expectDate': '待选择日期'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]setDate|  |  |  {'expectDate': '待选择日期'}

**注意事项**
* 方法目前只可以对日期进行选择不支持时间选择。
* 插件方法支持两种传值方式分别为 “[xx,xx...]列表顺序传参”、“{'参数名':'参数值'...}字典指定参数传参”，你可以根据实际情况书写。
* 根据你传入的日期，关键字会与当前组件中默认的日期进行大小值比较，并控制组件进行日期的“前”“后”跳转。
* 若你传入的日期与当前组件中默认的日期一致，则方法会直接点击组件中的【今天】按钮。
* 插件方法在在操作结束后，会初始化当前页面的iframe焦点，在使用结束后要注意iframe的层级关系(在调用时不必考虑该问题)。

## TipsSpringFrame方法 
> OA系统“右上角消息弹框”处理

**描述**<br/>
根据传入的“指定操作标识”，处理系统中右上角消息弹框

**参数**<br/>
@param **type** `string类型`：代表要对消息弹框进行操作的标识<br/>

**参数说明**
* 目前方法支持识别的操作标识固定为：`exit` 关闭消息弹框、` readAll` 已阅全部
> 操作标识区分大小写，在使用时注意检查是否正确

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]TipsSpringFrame|   |   {'type':'exit'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]TipsSpringFrame|  |  |   {'type':'exit'}

**注意事项**
* 插件方法支持两种传值方式分别为 “[xx,xx...]列表顺序传参”、“{'参数名':'参数值'...}字典指定参数传参”，你可以根据实际情况书写。
* 若页面中不存在消息提示框，则方法不会做任何操作。

## FormInput方法
> OA系统“复杂表单”内容填写

**描述**<br/>
对指定表单中的组件(input输入框、textarea多行文本输入框、radio单选按钮..)进行操作

**参数**<br/>
@param **Parent** `string类型`：指定表单节点的css定位表达式<br/>
@param **operationStep**`dict类型`：子项的key键名固定，对应的value值均为`list类型`，用来存放要操作的数据信息<br/>

**参数说明**
* Parent 参数解释：
	+ 目标表单的css定位表达式
* operationStep 参数key键名解释：
	+  键名为`input`代表对`<input type='text'>`文本输入框做操作
	+ 键名为`pass`代表对`<input type='pass'>`密码输入框做操作
	+ 键名为`textarea`代表对`<textarea></textarea>`多行文本输入框做操作
	+ 键名为`checkbox`代表对`<input type='checkbox'>`复选按钮做操作
	+ 键名为`radio`代表对`<input type='radio'>`单选按钮做操作
	+ 键名为`select`代表对`<select></select>`下拉列表框做操作
* operationStep 参数value值解释：
	+ 除键名为 “`select`” 的子项外，其它各键对应的value值均支持两种书写方式，分别为：
		+ “组件先后顺序操作”方式：[xx, xx, xx, xx ..]
		+ “指定组件操作”方式：[[Name, xx], [Name, xx], [] ..]
	+ 键名为 “`select`” 的子项，对应的value值仅支持一种书写方式，为：
		+ “指定组件操作”方式：[[Name, xx], [Name, xx], [] ..]
* operationStep传值格式示例：
	```python
	{
       'input': [xx, xx, xx, xx ..]   ||  [[Name, xx], [Name, xx], [] ..]    # 普通文本输入框

       'pass': [xx, xx, xx, xx ..]   ||  [[Name, xx], [Name, xx], [] ..]    # 密码文本输入框

       'textarea': [xx, xx, xx, xx ..]   ||  [[Name, xx], [Name, xx], [] ..]    # 多行文本输入框 
            
       'checkbox': [xx, xx, xx, xx ..]   ||  [[Name, xx], [Name, xx], [] ..]    # 复选框选择  

       'radio': [xx, xx, xx, xx ..]   ||  [[Name, xx], [Name, xx], [] ..]    # 单选框选择

       'select': [[Name, xx], [Name, xx], [] ..]    # 下拉列表框
    }
	```
* operationStep传值格式示例说明：
	+ “ xx ”为实际的操作值 (目前方法支持操作的表单组件)：
		+ 在`input输入框`、`pass密码输入框`、`textarea多行文本输入框`中该值应为文本类型；
		+ 在`checkbox复选按钮`、`radio单选按钮`中该值为布尔类型 (True代表选中该按钮，False代表不选中)；
		+ 在`select下拉列表框`中该值可以是其列表子项的 “index索引值”、“value属性值” 和 “text文本值” (方法自动识别传入的值类型，不需要特殊标明)；
	+ 传值方法分为两种，一种为 “`[xx, xx, xx, xx ..]` 按照组件先后顺序操作”，另一种为 “`[[Name, xx], [Name, xx], [] ..] ` 指定组件操作”。
		+ “按照组件先后顺序操作”：是按照对应表单组件在界面中的先后顺序进行操作，在使用时需要注意值输入顺序；
        +  “指定组件操作”：是按照传入的组件Name属性值对指定组件进行定位并操作，该方法不需要考虑顺序问题；
	+ 在使用 “按照组件先后顺序操作” 对`input输入框`、`pass密码输入框`、`textarea多行文本输入框`、`checkbox复选按钮`、`radio单选按钮`进行操作时，若实际的操作值(示例中的“xx”)为 `None` 则代表跳过不做操作。
	+ 无论使用哪种操作方法，在对`input输入框`、`pass密码输入框`、`textarea多行文本输入框`进行操作时，若实际的操作值(示例中的“xx”)为 `'clear'` 则代表只对输入框做清空操作，不输入任何值。

**方法使用场景示例**
> 测试场景：
> * 登录表单id属性值为`login`，用户名输入框name属性值为`userName`，密码输入框name属性值为`userPass`
> * 信息修改表单name属性值为`inform`，姓名输入框name属性值为`name`，昵称输入框name属性值为`tranName`，年龄输入框name属性值为`age`，性别下拉列表框name属性值为`sex`
* 使用“按照组件先后顺序操作”操作方法，对登录表单进行填写：`{'Parent ':'#login','operationStep':{'input':['admin','123']}}`
* 使用“指定组件操作”操作方法，对登录表单进行填写：`{'Parent ':'#login','operationStep':{'input':[['userName','admin'],['userPass','123']]}}`
* 使用“指定组件操作”操作方法，对信息修改表单进行填写(昵称输入框不输入值)：`{'Parent ':'form[name="inform"]','operationStep':{'input':[['age','12'],['name','王小明']],'select':[['sex','男']]}}`
* 使用“按照组件先后顺序操作”操作方法，对信息修改表单进行填写(昵称输入框不输入值)：`{'Parent ':'form[name="inform"]','operationStep':{'input':['12',None,'王小明'],'select':[['sex','男']]}}`

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]FormInput|   |   {'Parent':'表单定位表达式', 'operationStep':'操作数据'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]FormInput|  |  |  {'Parent':'表单定位表达式', 'operationStep':'操作数据'}

**注意事项**
* 插件方法仅支持一种传值方式：“{'参数名':'参数值'...}字典指定参数传参”。
* 方法按照 “组件先后顺序操作” 方式进行操作，若传入的操作值个数大于实际的元素个数，则超出的操作值将被方法视为无效，且不对其进行操作。
* 方法中的 “组件先后顺序操作方式” 和 “指定组件操作方式” 在不同表单组件元素之间可以混合使用，但是同种表单组件元素只可以二选一，例如，你可以在一次调用中使用“组件先后顺序操作方式”操作input输入框，同时使用“指定组件操作方式”操作radio单选按钮，但是不能对第一个input输入框使用“组件先后顺序操作方式”操作，对第二个input输入框使用“指定组件操作方式”操作。
* 方法中`select下拉列表框`只支持通过 “指定组件操作方式” 进行操作，若“操作值个数大于实际的元素个数，超出的操作值将视为无效”特性不受用。
* 方法中除`select下拉列表框`外其它表单组件不论使用 “组件先后顺序操作方式” 还是 “指定组件操作方式”，“操作值个数大于实际的元素个数，超出的操作值将视为无效”这个特性均受用。

## goto_Modular方法 
> OA系统“菜单模块”跳转

**描述**<br/>
根据传入的“OA系统菜单标识”，进行相应的模块跳转

**参数**<br/>
@param **firstIden** `string类型`：OA系统一级模块标识<br/>
@param **secondIden** `string类型`：OA系统二级模块标识<br/>
@param **thirdIden** `string类型`：OA系统三级模块标识<br/>
@param **tagIden** `int类型 / string类型`：对应模块tag标签标识<br/>
@param **localSwitch** `布尔类型`：局部操作开关<br/>
> firstIden 一级模块标识、secondIden 二级模块标识、thirdIden 三级模块标识，值均固定为特殊的字符标识，详情见<a target="blank" href="../../pages/jinJieShiYong/goto_modular.html" target="_blank">《goto_Modular()插件方法 -- TDOA web端模块菜单标识》</a>

> 严格意义上来说方法中的参数并没有“可省略”这一概念，你需要根据实际需要选择要填写那些参数；具体的参数使用规则见下文 **参数说明**

**参数说明**
* 全局操作；目标模块不存在子模块和tag标签页(例如：“个人事务-电子邮件”)：
	+ `{'firstIden':'personalAffairs','secondIden':'E_Mail'}` 或者 `['personalAffairs','E_Mail']`
* 全局操作；目标模块不存在子模块但存在tag标签页(例如：“个人事务-消息管理-微讯”)：
	+ `{'firstIden':'personalAffairs','secondIden':'Message','tagIden':0}`
* 全局操作；目标模块存在子模块但不存在tag标签页(例如：“行政办公-工作计划-工作计划类型设置”)： 
	+ `{'firstIden':'administrativeOffice','secondIden':'Work_Plan','thirdIden':'Work_Plan_Type'}` 或者 `['administrativeOffice','Work_Plan','Work_Plan_Type']`
* 全局操作：目标模块存在子模块同时也存在tag标签页(例如：“行政办公-工作计划-工作计划管理-新建工作计划”)：  
	+ `{'firstIden':'administrativeOffice','secondIden':'Work_Plan','thirdIden':'Work_Plan_Query', 'tagIden':1}` 或者 `['administrativeOffice','Work_Plan','Work_Plan_Query',1]`
* 局部操作：目标模块不存在tag标签页(例如：“个人事务-电子邮件” 、“行政办公-工作计划-工作计划类型设置”)：
	+ 进行一次全局操作(全局路由跳转),将模块跳转至“个人事务-电子邮件”模块 → 用例步骤 → 用例步骤 →... → `{'localSwitch':True}`
	+ 进行一次全局操作(全局路由跳转),将模块跳转至“行政办公-工作计划-工作计划类型设置”模块 → 用例步骤 → 用例步骤 →... → `{'localSwitch':True}`
* 局部操作：目标模块存在tag标签页(例如：“个人事务-消息管理-微讯” 、“行政办公-工作计划-工作计划管理-新建工作计划”)：
	+ 进行一次全局操作(全局路由跳转),将模块跳转至“个人事务-消息管理-微讯”模块 → 用例步骤 → 用例步骤 →... → `{'tagIden':0,'localSwitch':True}`
	+ 进行一次全局操作(全局路由跳转),将模块跳转至“行政办公-工作计划-工作计划管理-新建工作计划”模块 → 用例步骤 → 用例步骤 →... → `{'tagIden':1, 'localSwitch':True}`

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]goto_Modular|   |   {'firstIden':'一级模块标识','secondIden':'二级模块标识','thirdIden':'三级模块标识','tagIden':'模块tag标签标识','localSwitch': '局部操作开关'}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]goto_Modular|  |  |  {'firstIden':'一级模块标识','secondIden':'二级模块标识','thirdIden':'三级模块标识','tagIden':'模块tag标签标识','localSwitch': '局部操作开关'}

**注意事项**
* 方法适用于OA系统中的所有模块，包含所有“一级模块、二级模块、三级模块、tag页模块”；主要目的是为了简化“用例步骤文件”中的模块跳转步骤。
* 方法不会校验“各模块标识之间的层级关系是否有效以及其标识是否合法”，所以在使用时要注意检查你要操作的“模块标识”和“多级模块层级”是否正确。
* 方法传入的“`tagIden`对应模块tag标签标识”你只要确定其为阿拉伯数字即可，不必在意它的类型，在方法中会进行类型转换。
* 方法 “全局操作”：不考虑当前正在处于活动状态的“模块”，直接将整个OA系统还原成初始状态(无任何菜单展开，无任何模块打开)，并根据传入的各级标识打开指定的目标模块。
* 方法 “局部操作”：不会对系统“展开菜单项”和“定位任务标签”进行清空操作，而是直接跳过一、二级模块直接以三级模块或者tag标签模块为起点进行操作。
* 方法 “局部操作”不需要指定“各级模块标识”，但需要在调用方法进行“目标模块的局部操作”之前先调用方法完成一次“目标模块的全局操作”，目的则是为了获取“全局操作”所指定的各级模块标识信息。
* 方法 “局部操作”不支持用于模块之间的跳转，其本身目的只是为了用来刷新目标模块。
* 在使用“局部操作”刷新目标模块时，若不传入“`tagIden`对应模块tag标签标识”(不论目标模块有无tag标签页)则代表将该模块关闭(顶部选项卡)，并重新点击打开。

## intervention_Mysql方法 
> OA系统“数据库”操作

**描述**<br/>
根据传入数据库和数据表信息，连接并操作数据记录

**参数**<br/>
@param **localhost** `string类型`：mysql数据库地址<br/>
@param **port** `string类型 / int类型`： 端口号<br/>
@param **user** `string类型`：用户名<br/>
@param **password** `string类型`：密码<br/>
@param **charset** `string类型`：字符编码<br/>
@param **database** `string类型`：待操作数据库名称<br/>
@param **table** `string类型`：待操作数据表名称<br/>
@param **operation** `string类型`：操作标识<br/>
@param **where** `string类型`：sql条件命令表达式<br/>
@param **instructString** `dist类型`：字段名、字段值关系表达式<br/>
> where、instructString 参数可省略

**参数说明**
* localhost：mysql数据库地址，没有特殊要求；
* port：mysql服务的端口号，没有特殊要求你只要确定其为阿拉伯数字即可，不必在意它的类型，在方法中会进行类型转换；
* user：mysql服务的用户名，没有特殊要求；
* password：mysql服务的用户密码，没有特殊要求；
* charset：字符编码，没有特殊要求；
* database：待操作数据库的名称，没有特殊要求但要确保被操作的数据库真实存在；
* table：待操作数据表的名称，确保被操作的数据表真实存在，且存在于`database 参数`指定的数据库中；
* operation：操作标识，可输入值固定为 `delete`删除、`update`修改更新、`insert`插入；
* where：sql条件命令表达式，语法和sql一致 `"'字段名'='字段值' AND ..."`，需要注意其中的 “字段名” 和 “字段值” 在书写时需要用 `` 符号包裹；
* instructString：字段名、字段值关系表达式 `{'字段名':'值', '字段名': '值'...}`，需要注意其中的 “字段名” 和 “字段值” 在书写时不需要用 `` 符号包裹。
*  “where参数” 和 “instructString参数” 可选项说明：
	+ 当“operation操作动词”为 delete删除时：
		+  where可选填；有值且合法：则删除数据表中符合条件的记录，值为空或者无该项：则删除数据表中全部记录；
		+ instructString不参与处理，有无均可；
	+ 当“operation操作动词”为 update更新时：
		+ where可选填；有值且合法：则修改数据表中符合条件的记录，值为空或者无该项：则修改数据表中全部记录；
		+ instructString必填项；代表要修改的字段名和其对应的字段值(保证书写的字段名和值类型与表中实际对应)，`{'name'='王小明', 'age': '12'}`；
	+ 当“operation操作动词”为 insert插入时：
		+ where不参与处理，有无均可；
		+ instructString必填项；代表要插入记录的所有非空字段的字段名和其对应的字段值(保证书写的字段名和值类型与表中实际对应)，`{'name'='王小明', 'age': '12', 'class':'六年级', 'xb':'男'}`；

**方法使用场景示例**
* 实例一 
	+ 删除 student表中所有的记录：`information = {table: 'studnet', operation: 'delete'}`
	+ 删除 student表中 name字段值为“王小明”的记录：`information = {table: 'studnet', operation: 'delete', where: "'name'='王小明'"}`
* 实例二
	+ 将 student表中所有记录的 name字段值全部修改为 “王小明”：`information = {table: 'studnet', operation: 'update', instructString: {'name': '王小明'}}`
	+ 将 student表中 age字段值为0的记录的 name字段值修改为 “王小明”：`information = {table: 'studnet', operation: 'update', instructString: {'name': '王小明'}, where: "'age'='0'"}`
* 实例三
	+ 向 student表中插入一条记录，其 name字段值为“王小明”、age字段值为12、class字段值为“六年级”、sex字段值为“男”：`information = {table: 'studnet', operation: 'insert', 'instructString': {'name':'王小明', 'age': '12', 'class':'六年级', 'xb':'男'}}`

> 为了方便阅读和理解，在上面的实例中并没有书写 “localhost、 port” 等信息，但是在实际使用时除了 “where参数” 和 “instructString参数”两项外其它均是必填项。

**用例步骤使用示例**
用例name     | 序号     | 操作步骤    | 关键字     | 元素定位信息  | 操作值
------- | -----  | -----  | -----  | -----  | :----- 
区分元素定位数据 | n | xxx | [OA_webUI]intervention_Mysql|   |  {}

用例name     | 序号     | 操作步骤    | 关键字    | 定位方式 | 定位表达式  | 操作值
-------- | -----  | -----  | -----  | -----  | ----- | :----
不区分元素定位数据 | n | xxx  | [OA_webUI]intervention_Mysql|  |  |  {}

**注意事项**
* 方法目前仅支持对mysql数据库做操作

# 框架内置函数说明
## 内置函数说明 
内置函数：这里说的“内置函数”并不是函数方法，而是在框架中保留的带有特殊意义的字符串。目前框架中可支持识别的“内置函数”共有8个，其各自的函数名称以及所代表的含义如下所示：

> 注意：
- “内置函数”只有在用例步骤的“操作值”单元格或着脚本关键字的实参参数值中书写才可被框架识别并处理。
- “内置函数”中的参数不论在何种场景下均不需要使用引号包裹，例如 `['System_date(%Y-%m-%d %H:%M:%S)']`  或者 `{'key': 'get_thisMonth(end)'}` 或者 `Increasing_date(2023-05-18, 1)`。
- 存在联系的“内置函数”之间可以嵌套使用。
- “内置函数”没有使用个数和嵌套层级限制，你可以在一个“操作值单元格”或者“实参参数值”中书写或者嵌套多个“内置函数”，这并不会影响框架的识别。
- “内置函数”只能作为“操作值”或者“参数值”的一部分来参与执行，所以它必须要配合关键字或者插件方法一起使用，单独使用没有意义。

## System_date函数 
`System_date()函数`：需要携带参数使用，携带参数为“日期时间格式字符串(%Y-%m-%d %H:%M:%S)”；代表返还一个指定格式的系统当前日期时间数据。示例如下：
处理前 | 处理后    
---- | -----  
System_date(%Y-%m-%d %H:%M:%S) | 2022-07-15 15:09:34
System_date(%Y-%m-%d) | 2022-07-15

**参数**<br/>
日期格式字符串(%Y-%m-%d %H:%M:%S)

**说明**<br/>
获取当前系统日期时间，根据传入的“日期格式字符串”生成对应格式的日期时间数据。

## Increasing_date函数  
`Increasing_date()函数`：需要携带参数使用，携带参数为“日期时间字符串, 递增值”；代表对一个指定的“日期时间”进行递增，该函数可以和“`System_date()函数`”嵌套使用。示例如下：
 处理前 | 处理后    
---- | -----  
Increasing_date(2022-07-15 15:11:03, 1) |2022-07-16 15:11:03
Increasing_date(System_date(%Y-%m-%d), -1) | 2022-07-14
Increasing_date(System_date(%Y-%m-%d %H:%M:%S), -2) |2022-07-13 15:11:03

**参数**<br/>
日期时间数据, 递增天数  || System_date(日期格式字符串), 递增天数

**说明**<br/>
对指定的日期时间数据进行指定天数的自增。

## Intercept_date函数 
  `Intercept_date()函数`：需要携带参数使用，携带参数为“日期时间字符串, 截取类型”；代表对一个指定的“日期时间”进行指定部分的(Year年 / Month月 / Day日 / Hour时 / Min分 / Second秒)拆分，该函数同样可以和“`System_date()函数`”嵌套使用。示例如下：
 处理前 | 处理后    
---- | -----  
Intercept_date(2022-07-15 15:11:03, Year) | 2022
Intercept_date(System_date(%Y-%m-%d), Month) | 7
Intercept_date(Increasing_date(System_date(%Y-%m-%d %H:%M:%S), -2),Day) |  13
Intercept_date(System_date(%Y-%m-%d %H:%M:%S),Hour) |  15

**参数**<br/>
日期数据数据, 截取标识  || System_date(日期格式字符串), 截取标识

**说明**<br/>
对指定的日期时间数据进行“Y年、m月、d日、H时、M分、S秒”单个位置的数据提取。
截取标识：Year年 || Month月  || Day日  || Hour时 || Min分 || Second秒

## Mktime_date函数 
`Mktime_date()函数`：需要携带参数使用，携带参数为“日期时间字符串”；代表对一个指定的“日期时间”进行“时间戳转换”，该函数同样可以和“`System_date()函数`”嵌套使用。示例如下：
 处理前 | 处理后    
---- | -----  
Mktime_date(2022-07-15 15:16:03) | 1659457600
Mktime_date(System_date(%Y-%m-%d)) | 1659434400
Mktime_date(Increasing_date(System_date(%Y-%m-%d %H:%M:%S), 2)) | 1673474817

**参数**<br/>
日期数据数据  || System_date(日期格式字符串)

**说明**<br/>
将指定的日期时间数据转化成时间戳形式。

## get_thisWeek函数 
`get_thisWeek()函数`：需要携带参数使用，携带参数为“start/end”；代表返还本周的开始日期/结束日期，示例如下：
 处理前 | 处理后    
---- | -----  
get_thisWeek(start) | 2022-07-11
get_thisWeek(end) | 2022-07-17

**参数**<br/>
start || end

**说明**<br/>
获取本周的起始和截止日期，传入start为获取起始日期，传入end为获取截止日期。

## get_thisMonth函数 
`get_thisMonth()函数`：需要携带参数使用，携带参数为“start/end”；代表返还本月的开始日期/结束日期，示例如下：
 处理前 | 处理后    
---- | -----  
get_thisMonth(start) | 2022-07-01
get_thisMonth(end) | 2022-07-31

**参数**<br/>
start || end

**说明**<br/>
获取本月的起始和截止日期，传入start为获取起始日期，传入end为获取截止日期。

## get_thisYear函数 
`get_thisYear()函数`：需要携带参数使用，携带参数为“start/end”；代表返还本年的开始日期/结束日期，示例如下：
 处理前 | 处理后
---- | -----  
get_thisYear(start) | 2022-01-01
get_thisYear(end) | 2022-12-31

**参数**<br/>
start || end

**说明**<br/>
获取本年的起始和截止日期，传入start为获取起始日期，传入end为获取截止日期。

## get_PrestoreData函数 
`get_PrestoreData()函数`：携带参数和不携带参数均可使用，携带参数为“key键”；代表将通过<a id="getElementText">`getElementText()关键字`</a> 存放在“元素信息缓存数据”中的数据取出，示例如下：
 处理前 | 处理后    
---- | -----  
get_PrestoreData(Key) | 取出缓存数据中，Key键对应的Value值
get_PrestoreData() | 取出缓存数据中，最后一个key键对应的value值

**参数**<br/>
数据在缓存时的key键 || 空

**说明**<br/>
将由<a id="getElementText">`getElementText()关键字`</a>缓存的数据值取出，若传入key键则取出对应的值；若不传入key键则默认将缓存数据中最后一个key键对应的value值取出；若传入的key键不存在则会抛出异常。

# 框架可识别替换标识说明
## 替换标识
替换标识：与“内置函数”等同，都是在框架中保留的带有特殊意义的字符串。目前框架中可支持识别的“替换标识”共有4个，其各自的名称以及所代表的含义如下所示：

> 注：
- “替换标识”只有在“操作值”单元格中书写才可被框架识别并处理，它们可以作为参数值与关键字或者插件方法一起使用。
- “替换标识”没有个数限制，你可以在一个“操作值单元格”或者“实参参数值”中书写多个相同或者不同的标识，这并不会影响框架的识别。
- 注意“替换标识”是区分大小写的，要严格按照规定书写，否则框架将无法识别。
- “替换标识”只能作为“操作值”或者“参数值”的一部分来参与执行，所以它必须要配合关键字或者插件方法一起使用，单独使用没有意义。

 标识 | 说明
---- | -----  
WORK_PATH-ROOT | 识别为当前框架工作目录的路径
WORK_PATH-PACKET | 识别为当前框架工作目录中“用例数据包”的路径
WORK_PATH-INTERFACE | 识别为当前框架工作目录中“接口数据文件夹”的路径
WORK_PATH-ELEMENT | 识别为当前框架工作目录中“元素节点数据文件夹”的路径